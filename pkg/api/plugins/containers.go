// Code generated by go-swagger; DO NOT EDIT.

//
//   Copyright (c) 2022 Intel Corporation.
//
//   SPDX-License-Identifier: Apache-2.0
//
//
//

package plugins

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Containers containers
//
// swagger:model containers
type Containers struct {

	// containers
	Containers []*ContainersItems0 `json:"containers"`
}

// Validate validates this containers
func (m *Containers) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateContainers(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Containers) validateContainers(formats strfmt.Registry) error {
	if swag.IsZero(m.Containers) { // not required
		return nil
	}

	for i := 0; i < len(m.Containers); i++ {
		if swag.IsZero(m.Containers[i]) { // not required
			continue
		}

		if m.Containers[i] != nil {
			if err := m.Containers[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("containers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("containers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this containers based on the context it is used
func (m *Containers) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateContainers(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Containers) contextValidateContainers(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Containers); i++ {

		if m.Containers[i] != nil {
			if err := m.Containers[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("containers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("containers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Containers) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Containers) UnmarshalBinary(b []byte) error {
	var res Containers
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ContainersItems0 containers items0
//
// swagger:model ContainersItems0
type ContainersItems0 struct {

	// args
	Args []string `json:"args"`

	// bind mounts
	BindMounts []*ContainersItems0BindMountsItems0 `json:"bindMounts"`

	// cap add
	CapAdd []string `json:"cap_add"`

	// command
	Command []string `json:"command"`

	// env
	Env []*ContainersItems0EnvItems0 `json:"env"`

	// force
	Force bool `json:"force,omitempty"`

	// host name
	// Pattern: ^[a-zA-Z_$][a-zA-Z_.\-$0-9]*$
	HostName string `json:"hostName,omitempty"`

	// host network
	HostNetwork bool `json:"hostNetwork,omitempty"`

	// image
	Image string `json:"image,omitempty"`

	// image pull policy
	// Enum: [IfNotPresent Always Never]
	ImagePullPolicy string `json:"imagePullPolicy,omitempty"`

	// name
	// Pattern: ^[a-zA-Z_$][a-zA-Z_.\-$0-9]*$
	Name string `json:"name,omitempty"`

	// networks
	Networks []string `json:"networks"`

	// ports
	Ports []*ContainersItems0PortsItems0 `json:"ports"`

	// read only rootfs
	ReadOnlyRootfs *bool `json:"readOnlyRootfs,omitempty"`

	// restart
	// Enum: [always no]
	Restart string `json:"restart,omitempty"`

	// run in background
	RunInBackground bool `json:"runInBackground,omitempty"`

	// security opt
	SecurityOpt []string `json:"securityOpt"`

	// tmpfs
	Tmpfs []string `json:"tmpfs"`

	// user in container
	UserInContainer string `json:"userInContainer,omitempty"`

	// volume mounts
	VolumeMounts []*ContainersItems0VolumeMountsItems0 `json:"volumeMounts"`
}

// Validate validates this containers items0
func (m *ContainersItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBindMounts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCapAdd(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnv(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateImagePullPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePorts(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRestart(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSecurityOpt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTmpfs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVolumeMounts(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ContainersItems0) validateBindMounts(formats strfmt.Registry) error {
	if swag.IsZero(m.BindMounts) { // not required
		return nil
	}

	for i := 0; i < len(m.BindMounts); i++ {
		if swag.IsZero(m.BindMounts[i]) { // not required
			continue
		}

		if m.BindMounts[i] != nil {
			if err := m.BindMounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bindMounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bindMounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var containersItems0CapAddItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["NET_ADMIN"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		containersItems0CapAddItemsEnum = append(containersItems0CapAddItemsEnum, v)
	}
}

func (m *ContainersItems0) validateCapAddItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, containersItems0CapAddItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ContainersItems0) validateCapAdd(formats strfmt.Registry) error {
	if swag.IsZero(m.CapAdd) { // not required
		return nil
	}

	for i := 0; i < len(m.CapAdd); i++ {

		// value enum
		if err := m.validateCapAddItemsEnum("cap_add"+"."+strconv.Itoa(i), "body", m.CapAdd[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *ContainersItems0) validateEnv(formats strfmt.Registry) error {
	if swag.IsZero(m.Env) { // not required
		return nil
	}

	for i := 0; i < len(m.Env); i++ {
		if swag.IsZero(m.Env[i]) { // not required
			continue
		}

		if m.Env[i] != nil {
			if err := m.Env[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("env" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("env" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ContainersItems0) validateHostName(formats strfmt.Registry) error {
	if swag.IsZero(m.HostName) { // not required
		return nil
	}

	if err := validate.Pattern("hostName", "body", m.HostName, `^[a-zA-Z_$][a-zA-Z_.\-$0-9]*$`); err != nil {
		return err
	}

	return nil
}

var containersItems0TypeImagePullPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["IfNotPresent","Always","Never"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		containersItems0TypeImagePullPolicyPropEnum = append(containersItems0TypeImagePullPolicyPropEnum, v)
	}
}

const (

	// ContainersItems0ImagePullPolicyIfNotPresent captures enum value "IfNotPresent"
	ContainersItems0ImagePullPolicyIfNotPresent string = "IfNotPresent"

	// ContainersItems0ImagePullPolicyAlways captures enum value "Always"
	ContainersItems0ImagePullPolicyAlways string = "Always"

	// ContainersItems0ImagePullPolicyNever captures enum value "Never"
	ContainersItems0ImagePullPolicyNever string = "Never"
)

// prop value enum
func (m *ContainersItems0) validateImagePullPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, containersItems0TypeImagePullPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ContainersItems0) validateImagePullPolicy(formats strfmt.Registry) error {
	if swag.IsZero(m.ImagePullPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateImagePullPolicyEnum("imagePullPolicy", "body", m.ImagePullPolicy); err != nil {
		return err
	}

	return nil
}

func (m *ContainersItems0) validateName(formats strfmt.Registry) error {
	if swag.IsZero(m.Name) { // not required
		return nil
	}

	if err := validate.Pattern("name", "body", m.Name, `^[a-zA-Z_$][a-zA-Z_.\-$0-9]*$`); err != nil {
		return err
	}

	return nil
}

func (m *ContainersItems0) validatePorts(formats strfmt.Registry) error {
	if swag.IsZero(m.Ports) { // not required
		return nil
	}

	for i := 0; i < len(m.Ports); i++ {
		if swag.IsZero(m.Ports[i]) { // not required
			continue
		}

		if m.Ports[i] != nil {
			if err := m.Ports[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ports" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var containersItems0TypeRestartPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["always","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		containersItems0TypeRestartPropEnum = append(containersItems0TypeRestartPropEnum, v)
	}
}

const (

	// ContainersItems0RestartAlways captures enum value "always"
	ContainersItems0RestartAlways string = "always"

	// ContainersItems0RestartNo captures enum value "no"
	ContainersItems0RestartNo string = "no"
)

// prop value enum
func (m *ContainersItems0) validateRestartEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, containersItems0TypeRestartPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ContainersItems0) validateRestart(formats strfmt.Registry) error {
	if swag.IsZero(m.Restart) { // not required
		return nil
	}

	// value enum
	if err := m.validateRestartEnum("restart", "body", m.Restart); err != nil {
		return err
	}

	return nil
}

var containersItems0SecurityOptItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["no-new-privileges"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		containersItems0SecurityOptItemsEnum = append(containersItems0SecurityOptItemsEnum, v)
	}
}

func (m *ContainersItems0) validateSecurityOptItemsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, containersItems0SecurityOptItemsEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ContainersItems0) validateSecurityOpt(formats strfmt.Registry) error {
	if swag.IsZero(m.SecurityOpt) { // not required
		return nil
	}

	for i := 0; i < len(m.SecurityOpt); i++ {

		// value enum
		if err := m.validateSecurityOptItemsEnum("securityOpt"+"."+strconv.Itoa(i), "body", m.SecurityOpt[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *ContainersItems0) validateTmpfs(formats strfmt.Registry) error {
	if swag.IsZero(m.Tmpfs) { // not required
		return nil
	}

	for i := 0; i < len(m.Tmpfs); i++ {

		if err := validate.Pattern("tmpfs"+"."+strconv.Itoa(i), "body", m.Tmpfs[i], `^[a-zA-Z.\/][a-zA-Z0-9-_.\/]*$`); err != nil {
			return err
		}

	}

	return nil
}

func (m *ContainersItems0) validateVolumeMounts(formats strfmt.Registry) error {
	if swag.IsZero(m.VolumeMounts) { // not required
		return nil
	}

	for i := 0; i < len(m.VolumeMounts); i++ {
		if swag.IsZero(m.VolumeMounts[i]) { // not required
			continue
		}

		if m.VolumeMounts[i] != nil {
			if err := m.VolumeMounts[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumeMounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumeMounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this containers items0 based on the context it is used
func (m *ContainersItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBindMounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnv(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePorts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVolumeMounts(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ContainersItems0) contextValidateBindMounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BindMounts); i++ {

		if m.BindMounts[i] != nil {
			if err := m.BindMounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bindMounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bindMounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ContainersItems0) contextValidateEnv(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Env); i++ {

		if m.Env[i] != nil {
			if err := m.Env[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("env" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("env" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ContainersItems0) contextValidatePorts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Ports); i++ {

		if m.Ports[i] != nil {
			if err := m.Ports[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ports" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ports" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ContainersItems0) contextValidateVolumeMounts(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VolumeMounts); i++ {

		if m.VolumeMounts[i] != nil {
			if err := m.VolumeMounts[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("volumeMounts" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("volumeMounts" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *ContainersItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContainersItems0) UnmarshalBinary(b []byte) error {
	var res ContainersItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ContainersItems0BindMountsItems0 containers items0 bind mounts items0
//
// swagger:model ContainersItems0BindMountsItems0
type ContainersItems0BindMountsItems0 struct {

	// host path
	// Pattern: ^[a-zA-Z.\/][a-zA-Z0-9-_.\/]*$
	HostPath string `json:"hostPath,omitempty"`

	// mount path
	// Pattern: ^[a-zA-Z.\/][a-zA-Z0-9-_.\/]*$
	MountPath string `json:"mountPath,omitempty"`

	// read only
	ReadOnly bool `json:"readOnly,omitempty"`
}

// Validate validates this containers items0 bind mounts items0
func (m *ContainersItems0BindMountsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHostPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMountPath(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ContainersItems0BindMountsItems0) validateHostPath(formats strfmt.Registry) error {
	if swag.IsZero(m.HostPath) { // not required
		return nil
	}

	if err := validate.Pattern("hostPath", "body", m.HostPath, `^[a-zA-Z.\/][a-zA-Z0-9-_.\/]*$`); err != nil {
		return err
	}

	return nil
}

func (m *ContainersItems0BindMountsItems0) validateMountPath(formats strfmt.Registry) error {
	if swag.IsZero(m.MountPath) { // not required
		return nil
	}

	if err := validate.Pattern("mountPath", "body", m.MountPath, `^[a-zA-Z.\/][a-zA-Z0-9-_.\/]*$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this containers items0 bind mounts items0 based on context it is used
func (m *ContainersItems0BindMountsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ContainersItems0BindMountsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContainersItems0BindMountsItems0) UnmarshalBinary(b []byte) error {
	var res ContainersItems0BindMountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ContainersItems0EnvItems0 containers items0 env items0
//
// swagger:model ContainersItems0EnvItems0
type ContainersItems0EnvItems0 struct {

	// name
	Name string `json:"name,omitempty"`

	// value
	Value string `json:"value,omitempty"`
}

// Validate validates this containers items0 env items0
func (m *ContainersItems0EnvItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this containers items0 env items0 based on context it is used
func (m *ContainersItems0EnvItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ContainersItems0EnvItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContainersItems0EnvItems0) UnmarshalBinary(b []byte) error {
	var res ContainersItems0EnvItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ContainersItems0PortsItems0 containers items0 ports items0
//
// swagger:model ContainersItems0PortsItems0
type ContainersItems0PortsItems0 struct {

	// container port
	ContainerPort int64 `json:"containerPort,omitempty"`

	// host IP
	// Pattern: (\b25[0-5]|\b2[0-4][0-9]|\b[01]?[0-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}\b
	HostIP string `json:"hostIP,omitempty"`

	// host port
	HostPort int64 `json:"hostPort,omitempty"`

	// protocol
	// Enum: [tcp udp]
	Protocol string `json:"protocol,omitempty"`
}

// Validate validates this containers items0 ports items0
func (m *ContainersItems0PortsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHostIP(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ContainersItems0PortsItems0) validateHostIP(formats strfmt.Registry) error {
	if swag.IsZero(m.HostIP) { // not required
		return nil
	}

	if err := validate.Pattern("hostIP", "body", m.HostIP, `(\b25[0-5]|\b2[0-4][0-9]|\b[01]?[0-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}\b`); err != nil {
		return err
	}

	return nil
}

var containersItems0PortsItems0TypeProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["tcp","udp"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		containersItems0PortsItems0TypeProtocolPropEnum = append(containersItems0PortsItems0TypeProtocolPropEnum, v)
	}
}

const (

	// ContainersItems0PortsItems0ProtocolTCP captures enum value "tcp"
	ContainersItems0PortsItems0ProtocolTCP string = "tcp"

	// ContainersItems0PortsItems0ProtocolUDP captures enum value "udp"
	ContainersItems0PortsItems0ProtocolUDP string = "udp"
)

// prop value enum
func (m *ContainersItems0PortsItems0) validateProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, containersItems0PortsItems0TypeProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *ContainersItems0PortsItems0) validateProtocol(formats strfmt.Registry) error {
	if swag.IsZero(m.Protocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolEnum("protocol", "body", m.Protocol); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this containers items0 ports items0 based on context it is used
func (m *ContainersItems0PortsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ContainersItems0PortsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContainersItems0PortsItems0) UnmarshalBinary(b []byte) error {
	var res ContainersItems0PortsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// ContainersItems0VolumeMountsItems0 containers items0 volume mounts items0
//
// swagger:model ContainersItems0VolumeMountsItems0
type ContainersItems0VolumeMountsItems0 struct {

	// host path
	// Pattern: ^[a-zA-Z.\/][a-zA-Z0-9-_.\/]*$
	HostPath string `json:"hostPath,omitempty"`

	// mount path
	// Pattern: ^[a-zA-Z.\/][a-zA-Z0-9-_.\/]*$
	MountPath string `json:"mountPath,omitempty"`

	// read only
	ReadOnly bool `json:"readOnly,omitempty"`
}

// Validate validates this containers items0 volume mounts items0
func (m *ContainersItems0VolumeMountsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHostPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMountPath(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ContainersItems0VolumeMountsItems0) validateHostPath(formats strfmt.Registry) error {
	if swag.IsZero(m.HostPath) { // not required
		return nil
	}

	if err := validate.Pattern("hostPath", "body", m.HostPath, `^[a-zA-Z.\/][a-zA-Z0-9-_.\/]*$`); err != nil {
		return err
	}

	return nil
}

func (m *ContainersItems0VolumeMountsItems0) validateMountPath(formats strfmt.Registry) error {
	if swag.IsZero(m.MountPath) { // not required
		return nil
	}

	if err := validate.Pattern("mountPath", "body", m.MountPath, `^[a-zA-Z.\/][a-zA-Z0-9-_.\/]*$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this containers items0 volume mounts items0 based on context it is used
func (m *ContainersItems0VolumeMountsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *ContainersItems0VolumeMountsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ContainersItems0VolumeMountsItems0) UnmarshalBinary(b []byte) error {
	var res ContainersItems0VolumeMountsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
